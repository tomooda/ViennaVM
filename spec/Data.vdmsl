module Data
exports all
definitions
types
     Byte = nat inv b == b < 0x100; -- 8bits unsigned integer
     Word = nat inv w == w < 0x10000; -- 16bits unsigned integer
     Dword = nat inv dw == dw < 0x100000000; -- 32bits unsigned integer
     Qword = nat inv qw == qw < 0x10000000000000000; -- 64bits unsigned integer
     OID = Qword; -- 64 bits unsigned integer
     Int = int
        inv i == i > -0x8000000000000000 and i < 0x8000000000000000; -- 63 bits signed integer
     Float :: sign : nat exponent : nat fraction : nat
        inv mk_Float(s, e, f) == (s < 2 and e < 0x100) and f < 0x1000000; -- 32 bits floating point
     Char = Dword; -- 32 bits unsigned int
     Pointer = nat inv p == p <= 0x100000000000000; -- 56 bits address

values
     /* oid tag flags */
     smallIntegerFlag = 1;
     immediateFlag = 2;
     /* immediate value oid tags */
     smallIntegerTag = 1;
     invalidTag = 0x0a;
     floatTag = 0x12;
     charTag = 0x1a;
	  /* common value oids */
     nilValue = 0x22;
     trueValue = 0x2a;
     falseValue = 0x32;
	/* default values */
     invalidOidValue = invalidTag;
     invalidIntValue = 0x7fffffffffffffff;
     invalidFloatValue = mk_Float(1, 255, 0x7fffff);
     invalidCharValue = 0xffffffff;
     invalidPointerValue = 0x100000000000000;

functions
    float2real : Float -> real
    float2real(x) ==
        (if x.sign = 0 then 1 else -1)
         * (if
                x.exponent = 0
            then
                x.fraction / 2 ** 149
            else
                (1 + x.fraction / 2 ** 23)  * exp(2, x.exponent - 127));
    
    real2float : real -> Float
    real2float(x) ==
        let
            a = abs x,
            f =
                if a < exp(2, -126) then denormalized_r2f(a) else normalized_r2f(a)
        in mk_Float(if x >= 0 then 0 else 1, f.exponent, f.fraction);
    
    normalized_r2f : real -> Float
    normalized_r2f(x) ==
        if x >= 2.0
            then (let f = normalized_r2f(x / 2.0)
                in mk_Float(f.sign, f.exponent + 1, f.fraction))
        elseif x < 1.0
            then let f = normalized_r2f(x  * 2.0)
            in mk_Float(f.sign, f.exponent - 1, f.fraction)
        else
            mk_Float(0, 127, floor ((x - 1)  * 2 ** 23))
    pre x >= 0;
    
    denormalized_r2f : real -> Float
    denormalized_r2f(x) ==
        mk_Float(0, 0, floor (x  * 2 ** (126 + 23)))
    pre x >= 0;
    
    exp : real * real -> real
    exp(x, y) == if y >= 0 then x ** y else 1.0 / x ** (abs y);
    
    qword2words : Qword -> Word * Word * Word * Word
    qword2words(i) ==
        let
            byte1 = i mod 0x10000,
            i1 = i div 0x10000,
            byte2 = i1 mod 0x10000,
            i2 = i1 div 0x10000,
            byte3 = i2 mod 0x10000,
            byte4 = i2 div 0x10000
        in mk_(byte1, byte2, byte3, byte4);
    
    int2qword : Int -> Qword
    int2qword(x) == if x < 0 then x + 0x10000000000000000 else x;
    
    qword2int : Qword -> Int
    qword2int(x) ==
        if x < 0x8000000000000000 then x else x - 0x10000000000000000;
    
    dword2int : Dword -> Int
    dword2int(x) == if x < 0x80000000 then x else x - 0x100000000;
    
    byte2int : Byte -> Int
    byte2int(x) == if x < 0x80 then x else x - 0x100;
    
    oid2int : OID -> Int
    oid2int(oid) ==
        if
            oid mod 2 = 1
        then
            (if oid <= 0x8000000000000000 then oid div 2 else oid div 2 - 0x8000000000000000)
        else
            invalidIntValue;
    
    int2oid : Int -> OID
    int2oid(i) ==
        if
            i <> invalidIntValue
        then
            (if i >= 0 then i  * 2 + 1 else (0x8000000000000000 + i)  * 2 + smallIntegerTag)
        else
            invalidOidValue;
    
    oid2float : OID -> Float
    oid2float(oid) ==
        if
            oid mod 0x100 = floatTag
        then
            (let
                    f : nat = oid div 0x100,
                    fraction : nat = f mod 0x800000,
                    signExponent : nat = f div 0x800000,
                    exponent : nat = signExponent mod 0x100,
                    sign : nat = signExponent div 0x100
                in mk_Float(sign, exponent, fraction))
        else
            invalidFloatValue;
    
    float2oid : Float -> OID
    float2oid(f) ==
        if
            f <> invalidFloatValue
        then
            f.sign  * 0x8000000000 + f.exponent  * 0x80000000
            + f.fraction  * 0x100
            + floatTag
        else
            invalidOidValue;
    
    oid2char : OID -> Char
    oid2char(oid) ==
        if oid mod 0x100 = charTag then oid div 0x100 else invalidCharValue;
    
    char2oid : Char -> OID
    char2oid(c) ==
        if c <> invalidCharValue then c  * 0x100 + charTag else invalidOidValue;
    
    oid2pointer : OID -> Pointer
    oid2pointer(oid) ==
        if oid mod 4 = 0 then oid div 0x100 else invalidPointerValue;
    
    pointer2oid : Pointer -> OID
    pointer2oid(p) ==
        if p <> invalidPointerValue then p  * 0x100 else invalidOidValue;

end Data
