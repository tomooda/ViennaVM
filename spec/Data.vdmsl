module Data
imports
    from Memory
        operations
            read_hash;
            write_hash;
            slots_size;
            read_slot;
exports all
definitions
types
     Byte = nat inv b == b < 0x100; -- 8bits unsigned integer
     Word = nat inv w == w < 0x10000; -- 16bits unsigned integer
     Dword = nat inv dw == dw < 0x100000000; -- 32bits unsigned integer
     Qword = nat inv qw == qw < 0x10000000000000000; -- 64bits unsigned integer
     OID = Qword; -- 64 bits unsigned integer
     Int = int
        inv i == i > -0x8000000000000000 and i < 0x8000000000000000; -- 63 bits signed integer
     Float :: sign : nat exponent : nat fraction : nat
        inv mk_Float(s, e, f) == (s < 2 and e < 0x100) and f < 0x1000000; -- 32 bits floating point
     Char = Dword; -- 32 bits unsigned int
     Pointer = nat inv p == p <= 0x100000000000000; -- 56 bits address

values
     /* oid tag flags */
     smallIntegerFlag = 1;
     immediateFlag = 2;
     typeFlag = 4;
     optionTypeFlag = 8;
     /* immediate value oid tags */
     smallIntegerTag = 1;
     invalidTag = 0x0a;
     floatTag = 0x12;
     charTag = 0x1a;
	  /* common value oids */
     nilValue = 0x22;
     trueValue = 0x2a;
     falseValue = 0x32;
     undefinedValue = 0x3a;
     emptySeqValue = 0x82;
     emptySetValue = 0x8a;
     emptyMapValue = 0x92;
     /* immediate type oid defs */
     unitType = 0x06;
     boolType = 0x16;
     charType = 0x26;
     realType = 0x36;
     intType = 0x46;
     natType = 0x56;
     nat1Type = 0x66;
     tokenType = 0x76;
     anyType = 0xf6;
     /* heap value oid defs */
     tupleRecordTag = 0x10;
     tokenTag = 0x20;
     seqTag = 0x30;
     setTag = 0x40;
     mapTag = 0x50;
     quoteTag = 0x60;
     functionTag = 0x70;
     operationTag = 0x80;
     largePositiveIntTag = 0x90;
     largeNegativeIntTag = 0xa0;
     /* heap type oid defs */
     tupleType = 0x04;
     recordType = 0x14;
     seqType = 0x24;
     setType = 0x34;
     mapType = 0x44;
     quoteType = 0x54;
     functionType = 0x64;
     operationType = 0x74;
     productType = 0x84;
     unionType = 0x94;
	  /* default values */
     invalidOidValue = invalidTag;
     invalidIntValue = 0x7fffffffffffffff;
     invalidFloatValue = mk_Float(1, 255, 0x7fffff);
     invalidCharValue = 0xffffffff;
     invalidPointerValue = 0x100000000000000;
     hashMask = 0xffffffff;

functions
    float2real : Float -> real
    float2real(x) ==
        (if x.sign = 0 then 1 else -1)
         * (if
                x.exponent = 0
            then
                x.fraction / 2 ** 149
            else
                (1 + x.fraction / 2 ** 23)  * exp(2, x.exponent - 127));
    
    real2float : real -> Float
    real2float(x) ==
        let
            a = abs x,
            f =
                if a < exp(2, -126) then denormalized_r2f(a) else normalized_r2f(a)
        in mk_Float(if x >= 0 then 0 else 1, f.exponent, f.fraction);
    
    normalized_r2f : real -> Float
    normalized_r2f(x) ==
        if x >= 2.0
            then (let f = normalized_r2f(x / 2.0)
                in mk_Float(f.sign, f.exponent + 1, f.fraction))
        elseif x < 1.0
            then let f = normalized_r2f(x  * 2.0)
            in mk_Float(f.sign, f.exponent - 1, f.fraction)
        else
            mk_Float(0, 127, floor ((x - 1)  * 2 ** 23 + 0.5))
    pre x >= 0;
    
    denormalized_r2f : real -> Float
    denormalized_r2f(x) ==
        mk_Float(0, 0, floor (x  * 2 ** (126 + 23) + 0.5))
    pre x >= 0;
    
    exp : real * real -> real
    exp(x, y) == if y >= 0 then x ** y else 1.0 / x ** (abs y);
    
    words2qword : Word * Word * Word * Word -> Qword
    words2qword(w1, w2, w3, w4) ==
        w4  * 0x1000000000000 + w3  * 0x100000000 + w2  * 0x10000 + w1;
    
    qword2words : Qword -> Word * Word * Word * Word
    qword2words(i) ==
        let
            byte1 = i mod 0x10000,
            i1 = i div 0x10000,
            byte2 = i1 mod 0x10000,
            i2 = i1 div 0x10000,
            byte3 = i2 mod 0x10000,
            byte4 = i2 div 0x10000
        in mk_(byte1, byte2, byte3, byte4);
    
    int2qword : int -> Qword
    int2qword(x) == if x < 0 then x + 0x10000000000000000 else x;
    
    qword2int : Qword -> int
    qword2int(x) ==
        if x < 0x8000000000000000 then x else x - 0x10000000000000000;
    
    dword2int : Dword -> int
    dword2int(x) == if x < 0x80000000 then x else x - 0x100000000;
    
    byte2int : Byte -> int
    byte2int(x) == if x < 0x80 then x else x - 0x100;
    
    oid2int : OID -> Int
    oid2int(oid) ==
        if
            oid mod 2 = 1
        then
            (if oid <= 0x8000000000000000 then oid div 2 else oid div 2 - 0x8000000000000000)
        else
            invalidIntValue;
    
    int2oid : Int -> OID
    int2oid(i) ==
        if
            i <> invalidIntValue
        then
            (if i >= 0 then i  * 2 + 1 else (0x8000000000000000 + i)  * 2 + smallIntegerTag)
        else
            invalidOidValue;
    
    oid2float : OID -> Float
    oid2float(oid) ==
        if
            oid mod 0x100 = floatTag
        then
            (let
                    f : nat = oid div 0x100,
                    fraction : nat = f mod 0x800000,
                    signExponent : nat = f div 0x800000,
                    exponent : nat = signExponent mod 0x100,
                    sign : nat = signExponent div 0x100
                in mk_Float(sign, exponent, fraction))
        else
            invalidFloatValue;
    
    float2oid : Float -> OID
    float2oid(f) ==
        if
            f <> invalidFloatValue
        then
            f.sign  * 0x8000000000 + f.exponent  * 0x80000000
            + f.fraction  * 0x100
            + floatTag
        else
            invalidOidValue;
    
    oid2char : OID -> Char
    oid2char(oid) ==
        if oid mod 0x100 = charTag then oid div 0x100 else invalidCharValue;
    
    char2oid : Char -> OID
    char2oid(c) ==
        if c <> invalidCharValue then c  * 0x100 + charTag else invalidOidValue;
    
    oid2pointer : OID -> Pointer
    oid2pointer(oid) ==
        if oid mod 4 = 0 then oid div 0x100 else invalidPointerValue;
    
    pointer2oid : Pointer -> OID
    pointer2oid(p) ==
        if p <> invalidPointerValue then p  * 0x100 else invalidOidValue;

operations
    pure hashInt : Int ==> Int
    hashInt(i) == return int2oid(i) mod (hashMask + 1);
    
    pure hashFloat : Float ==> Int
    hashFloat(f) ==
        let r = float2real(f), i = floor r
        in
            return if r - i = 0.0 then hashInt(i) else float2oid(f) mod (hashMask + 1);
    
    pure hashChar : Char ==> Int
    hashChar(c) == return char2oid(c) mod (hashMask + 1);
    
    hashPointer : Pointer ==> Int
    hashPointer(p) ==
        let basic_hash = Memory`read_hash(p)
        in
            (if
                basic_hash = invalidIntValue
            then
                (dcl h:Int := 0;
                for i = 1 to  Memory`slots_size(p)
                do h := (h + hash(Memory`read_slot(p, i))) mod (hashMask + 1);
                Memory`write_hash(p, h);
                return h)
            else
                return basic_hash);
    
    hash : OID ==> Int
    hash(oid) ==
        return if oid mod 4 = 0
                then hashPointer(oid2pointer(oid))
            elseif oid mod 0x100 = floatTag
                then hashFloat(oid2float(oid))
            else
                oid mod (hashMask + 1);

end Data
