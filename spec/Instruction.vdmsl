module Instruction
imports
    from Data all,
    from Memory all,
    from Register all
exports all
definitions
values
     ERR = 0x0000;
     NOP = 0x0001;
     ALLOC = 0x0002;
     RESET = 0x0003;
     MOVE = 0x0004;
     MOVEI = 0x0005;
     LOAD = 0x0006;
     LOADI = 0x0007;
     STORE = 0x0008;
     STOREI = 0x0009;
     ADD = 0x00010;
     ADDI = 0x0011;
     SUB = 0x0012;
     SUBI = 0x0013;
     MUL = 0x0014;
     MULI = 0x0015;
     IDIV = 0x0016;
     IDIVI = 0x0017;
     IMOD = 0x0018;
     IMODI = 0x0019;
     LESSTHAN = 0x0032;
     EQUAL = 0x0035;
     JUMP = 0x0048;
     JUMPTRUE = 0x0049;
     JUMPFALSE = 0x0050;

operations
    step : () ==> ()
    step() ==
        let i = Data`oid2int(fetch())
        in
            if
                i <> Data`invalidIntValue
            then
                let
                    code = Data`int2qword(i),
                    mk_(opcode, reg1, reg2, reg3) = Data`qword2words(code)
                in
                    (cases opcode:
                        (ERR) -> err(),
                        (NOP) -> nop(),
                        (ALLOC) -> alloc(reg1, reg2, reg3, fetch()),
                        (RESET) -> reset(reg1, reg2, reg3),
                        (MOVE) -> move(reg1, reg2, reg3),
                        (MOVEI) -> movei(reg1, reg2, reg3, fetch()),
                        (LOAD) -> load(reg1, reg2, reg3),
                        (LOADI) -> loadi(reg1, reg2, reg3, fetch()),
                        (STORE) -> store(reg1, reg2, reg3),
                        (STOREI) -> storei(reg1, reg2, fetch(), reg3),
                        (ADD) -> add(reg1, reg2, reg3),
                        (SUB) -> sub(reg1, reg2, reg3),
                        (MUL) -> mul(reg1, reg2, reg3),
                        (IDIV) -> idiv(reg1, reg2, reg3),
                        (IMOD) -> imod(reg1, reg2, reg3),
                        (LESSTHAN) -> lessthan(reg1, reg2, reg3),
                        (EQUAL) -> equal(reg1, reg2, reg3),
                        (JUMP) -> jump(reg1),
                        (JUMPTRUE) -> jumptrue(reg1, reg2),
                        (JUMPFALSE) -> jumpfalse(reg1, reg2),
                        others -> err()
                        end)
            else
                err();
    
    fetch : () ==> Data`OID
    fetch() ==
        let ip = Register`read_ip() + 1, cr = Register`read_cr()
        in
            (Register`write_ip(ip);
            if
                ip > 0 and ip <= Memory`slots_size(cr)
            then
                return Memory`read_slot(cr, ip)
            else
                (err();
                return Data`invalidOidValue));
    
    err : () ==> ()
    err() == error;
    
    nop : () ==> ()
    nop() == skip;
    
    alloc : Register`Register * Register`Register * Register`Register *
    Data`OID ==> ()
    alloc(reg1, reg2, reg3, imm) ==
        let size = Data`oid2int(imm)
        in
            if
                size <> Data`invalidIntValue
            then
                let p = Memory`alloc(size)
                in
                    if
                        p <> Data`invalidPointerValue
                    then
                        (if reg1 > 0 then Register`write_pointer(reg1, p);
                        if reg2 > 0 then Register`write_pointer(reg2, p);
                        if reg3 > 0 then Register`write_pointer(reg3, p))
                    else
                        err()
            else
                err();
    
    reset : Register`Register * Register`Register * Register`Register ==> ()
    reset(reg1, reg2, reg3) ==
        (if reg1 > 0 then Register`write_oid(reg1, Data`invalidOidValue);
        if reg2 > 0 then Register`write_oid(reg2, Data`invalidOidValue);
        if reg3 > 0 then Register`write_oid(reg3, Data`invalidOidValue));
    
    move : Register`Register * Register`Register * Register`Register ==> ()
    move(dst1, dst2, src) ==
        if
            src > 0
        then
            (if dst1 > 0 then Register`move(dst1, src);
            if dst2 > 0 then Register`move(dst2, src))
        else
            err();
    
    movei : Register`Register * Register`Register * Register`Register *
    Data`OID ==> ()
    movei(dst1, dst2, dst3, imm) ==
        if
            imm <> Data`invalidOidValue
        then
            (if dst1 > 0 then Register`write_oid(dst1, imm);
            if dst2 > 0 then Register`write_oid(dst2, imm);
            if dst3 > 0 then Register`write_oid(dst3, imm))
        else
            err();
    
    load : Register`Register * Register`Register * Register`Register ==> ()
    load(dst, src, intReg) ==
        if
            (dst > 0 and src > 0) and intReg > 0
        then
            let
                pointer = Register`read_pointer(src),
                slot = Register`read_int(intReg)
            in
                if
                    Memory`slots_size(pointer) >= slot
                then
                    Register`write_oid(dst, Memory`read_slot(pointer, slot))
                else
                    err()
        else
            err();
    
    loadi : Register`Register * Register`Register * Register`Register *
    Data`OID ==> ()
    loadi(dst, src, intReg, imm) ==
        let slot1 = Data`oid2int(imm)
        in
            if
                (slot1 <> Data`invalidIntValue and dst > 0) and src > 0
            then
                let
                    pointer = Register`read_pointer(src),
                    slot =
                        slot1 + (if intReg > 0 then Register`read_int(intReg) else 0)
                in
                    if
                        Memory`slots_size(pointer) >= slot
                    then
                        Register`write_oid(dst, Memory`read_slot(pointer, slot))
                    else
                        err()
            else
                err();
    
    store : Register`Register * Register`Register * Register`Register ==> ()
    store(dst, intReg, src) ==
        if
            (dst > 0 and src > 0) and intReg > 0
        then
            let
                pointer = Register`read_pointer(dst),
                slot = Register`read_int(intReg)
            in
                if
                    Memory`slots_size(pointer) >= slot
                then
                    Memory`write_slot(pointer, slot, Register`read_oid(src))
                else
                    err()
        else
            err();
    
    storei : Register`Register * Register`Register * Data`OID *
    Register`Register ==> ()
    storei(dst, intReg, imm, src) ==
        let slot1 = Data`oid2int(imm)
        in
            if
                (slot1 <> Data`invalidIntValue and dst > 0) and src > 0
            then
                let
                    pointer = Register`read_pointer(dst),
                    slot =
                        slot1 + (if intReg > 0 then Register`read_int(intReg) else 0)
                in
                    if
                        Memory`slots_size(pointer) >= slot
                    then
                        Memory`write_slot(pointer, slot, Register`read_oid(src))
                    else
                        err()
            else
                err();
    
    add : Register`Register * Register`Register * Register`Register ==> ()
    add(dst, src1, src2) ==
        if
            (dst > 0 and src1 > 0) and src2 > 0
        then
            let
                int1 = Register`read_int(src1),
                num1 : [real] =
                    if
                        int1 <> Data`invalidIntValue
                    then
                        int1
                    else
                        (let float1 = Register`read_float(src1)
                            in
                                (if float1 <> Data`invalidFloatValue then Data`float2real(float1) else nil)),
                int2 = Register`read_int(src2),
                num2 : [real] =
                    if
                        int2 <> Data`invalidIntValue
                    then
                        int2
                    else
                        (let float2 = Register`read_float(src2)
                            in
                                (if float2 <> Data`invalidFloatValue then Data`float2real(float2) else nil))
            in
                if
                    num1 <> nil and num2 <> nil
                then
                    let num3 : real = num1 + num2
                    in
                        if
                            int1 <> Data`invalidIntValue and int2 <> Data`invalidIntValue
                        then
                            Register`write_int(dst, num3)
                        else
                            Register`write_float(dst, Data`real2float(num3))
                else
                    err()
        else
            err();
    
    sub : Register`Register * Register`Register * Register`Register ==> ()
    sub(dst, src1, src2) ==
        if
            (dst > 0 and src1 > 0) and src2 > 0
        then
            let
                int1 = Register`read_int(src1),
                num1 : [real] =
                    if
                        int1 <> Data`invalidIntValue
                    then
                        int1
                    else
                        (let float1 = Register`read_float(src1)
                            in
                                (if float1 <> Data`invalidFloatValue then Data`float2real(float1) else nil)),
                int2 = Register`read_int(src2),
                num2 : [real] =
                    if
                        int2 <> Data`invalidIntValue
                    then
                        int2
                    else
                        (let float2 = Register`read_float(src2)
                            in
                                (if float2 <> Data`invalidFloatValue then Data`float2real(float2) else nil))
            in
                if
                    num1 <> nil and num2 <> nil
                then
                    let num3 : real = num1 - num2
                    in
                        if
                            int1 <> Data`invalidIntValue and int2 <> Data`invalidIntValue
                        then
                            Register`write_int(dst, num3)
                        else
                            Register`write_float(dst, Data`real2float(num3))
                else
                    err()
        else
            err();
    
    mul : Register`Register * Register`Register * Register`Register ==> ()
    mul(dst, src1, src2) ==
        if
            (dst > 0 and src1 > 0) and src2 > 0
        then
            let
                int1 = Register`read_int(src1),
                num1 : [real] =
                    if
                        int1 <> Data`invalidIntValue
                    then
                        int1
                    else
                        (let float1 = Register`read_float(src1)
                            in
                                (if float1 <> Data`invalidFloatValue then Data`float2real(float1) else nil)),
                int2 = Register`read_int(src2),
                num2 : [real] =
                    if
                        int2 <> Data`invalidIntValue
                    then
                        int2
                    else
                        (let float2 = Register`read_float(src2)
                            in
                                (if float2 <> Data`invalidFloatValue then Data`float2real(float2) else nil))
            in
                if
                    num1 <> nil and num2 <> nil
                then
                    let num3 : real = num1  * num2
                    in
                        if
                            int1 <> Data`invalidIntValue and int2 <> Data`invalidIntValue
                        then
                            Register`write_int(dst, num3)
                        else
                            Register`write_float(dst, Data`real2float(num3))
                else
                    err()
        else
            err();
    
    fdiv : Register`Register * Register`Register * Register`Register ==> ()
    fdiv(dst, src1, src2) ==
        if
            (dst > 0 and src1 > 0) and src2 > 0
        then
            let
                num1 : [real] =
                    let float1 = Register`read_float(src1)
                    in
                        (if float1 <> Data`invalidFloatValue then Data`float2real(float1) else nil),
                num2 : [real] =
                    let float2 = Register`read_float(src2)
                    in
                        (if float2 <> Data`invalidFloatValue then Data`float2real(float2) else nil)
            in
                if
                    (num1 <> nil and num2 <> nil) and num2 <> 0
                then
                    Register`write_float(dst, Data`real2float(num1 / num2))
                else
                    err()
        else
            err();
    
    idiv : Register`Register * Register`Register * Register`Register ==> ()
    idiv(dst, src1, src2) ==
        let
            int1 : Data`Int = if src1 > 0 then Register`read_int(src1) else 1,
            int2 : Data`Int = if src2 > 0 then Register`read_int(src2) else 1
        in
            if
                (int1 <> Data`invalidIntValue and int2 <> Data`invalidIntValue)
                and dst > 0
            then
                Register`write_int(dst, int1 div int2)
            else
                err();
    
    imod : Register`Register * Register`Register * Register`Register ==> ()
    imod(dst, src1, src2) ==
        let
            int1 : Data`Int =
                if src1 > 0 then Register`read_int(src1) else Data`invalidIntValue,
            int2 : Data`Int =
                if src2 > 0 then Register`read_int(src2) else Data`invalidIntValue
        in
            if
                (int1 <> Data`invalidIntValue and int2 <> Data`invalidIntValue)
                and dst > 0
            then
                Register`write_int(dst, int1 mod int2)
            else
                err();
    
    lessthan : Register`Register * Register`Register * Register`Register ==> ()
    lessthan(dst, src1, src2) ==
        if
            (dst > 0 and src1 > 0) and src2 > 0
        then
            let
                int1 = Register`read_int(src1),
                num1 : [real] =
                    if
                        int1 <> Data`invalidIntValue
                    then
                        int1
                    else
                        (let float1 = Register`read_float(src1)
                            in
                                (if float1 <> Data`invalidFloatValue then Data`float2real(float1) else nil)),
                int2 = Register`read_int(src2),
                num2 : [real] =
                    if
                        int2 <> Data`invalidIntValue
                    then
                        int2
                    else
                        (let float2 = Register`read_float(src2)
                            in
                                (if float2 <> Data`invalidFloatValue then Data`float2real(float2) else nil))
            in
                if
                    num1 <> nil and num2 <> nil
                then
                    Register`write_oid(dst, if num1 < num2 then Data`trueValue else Data`falseValue)
                else
                    err()
        else
            err();
    
    equal : Register`Register * Register`Register * Register`Register ==> ()
    equal(dst, src1, src2) ==
        if
            (dst > 0 and src1 > 0) and src2 > 0
        then
            let
                int1 = Register`read_int(src1),
                num1 : [real] =
                    if
                        int1 <> Data`invalidIntValue
                    then
                        int1
                    else
                        (let float1 = Register`read_float(src1)
                            in
                                (if float1 <> Data`invalidFloatValue then Data`float2real(float1) else nil)),
                int2 = Register`read_int(src2),
                num2 : [real] =
                    if
                        int2 <> Data`invalidIntValue
                    then
                        int2
                    else
                        (let float2 = Register`read_float(src2)
                            in
                                (if float2 <> Data`invalidFloatValue then Data`float2real(float2) else nil))
            in
                if
                    num1 <> nil and num2 <> nil
                then
                    Register`write_oid(dst, if num1 = num2 then Data`trueValue else Data`falseValue)
                else
                    err()
        else
            err();
    
    jump : Register`Register ==> ()
    jump(intReg) ==
        if
            intReg > 0
        then
            let ip = Register`read_int(intReg)
            in
                if ip <> Data`invalidIntValue then Register`write_ip(ip) else err()
        else
            err();
    
    jumptrue : Register`Register * Register`Register ==> ()
    jumptrue(boolReg, intReg) ==
        if
            boolReg > 0 and intReg > 0
        then
            let b = Register`read_oid(boolReg), ip = Register`read_int(intReg)
            in
                if
                    ip <> Data`invalidIntValue
                then
                    cases b:
                        (Data`trueValue) -> Register`write_ip(ip),
                        (Data`falseValue) -> skip,
                        others -> err()
                        end
                else
                    err()
        else
            err();
    
    jumpfalse : Register`Register * Register`Register ==> ()
    jumpfalse(boolReg, intReg) ==
        if
            boolReg > 0 and intReg > 0
        then
            let b = Register`read_oid(boolReg), ip = Register`read_int(intReg)
            in
                if
                    ip <> Data`invalidIntValue
                then
                    cases b:
                        (Data`trueValue) -> skip,
                        (Data`falseValue) -> Register`write_ip(ip),
                        others -> err()
                        end
                else
                    err()
        else
            err();

end Instruction
