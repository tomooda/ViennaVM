module Memory
imports
    from Data
        types
            Byte renamed Byte;
            Word renamed Word;
            Dword renamed Dword;
            Qword renamed Qword;
            Pointer renamed Pointer;
        values invalidPointerValue renamed invalidPointerValue;
exports all
definitions
types
     Slot :: address : Pointer size : Qword;

values
     /* CONSTANTS ON MEMORY SPACE */
     ALIGNMENT = 64;
     HEAP_PAGE_SIZE = 1024;
     POOL_PAGE_SIZE = HEAP_PAGE_SIZE div ALIGNMENT;
     /* DATA STRUCTURE OF ALLOCATED MEMORY */
     SIZE_OFFSET = 0; -- dword
     FLAGS_OFFSET = 4; -- dword
     REFERENCE_COUNT_OFFSET = 8; -- qword
     FORWARDER_OFFSET = 16; -- qword
     CONTENT_OFFSET = 24;
     /* FLAGS IN "basic_read_dword(pointer + FLAGS_OFFSET)" */
     LARGE_OBJECT_FLAG = 1; --- if 1, the object is a large virtual object

functions
    align : Qword -> Qword
    align(x) == ((x - 1) div ALIGNMENT + 1)  * ALIGNMENT;

state State of
    heapPages : seq of (seq of Byte)
    poolPages : seq of (seq of Slot)
    poolCleanerPageIndex : nat1
    poolCleanerIndex : nat1
inv mk_State(heaps, pools, pageIndex, index) ==
    (len heaps = len pools and pageIndex <= len pools)
    and index <= POOL_PAGE_SIZE
init s ==
    s
    = mk_State(
        [[0 | i in set {1, ..., HEAP_PAGE_SIZE}]],
        [[mk_Slot(0, HEAP_PAGE_SIZE)]
        ^ [mk_Slot(0, 0) | i in set {1, ..., POOL_PAGE_SIZE - 1}]],
        1,
        1)
end

operations
    initialize : () ==> ()
    initialize() ==
        atomic(heapPages := [[0 | i in set {1, ..., HEAP_PAGE_SIZE}]];
            poolPages
                := [[mk_Slot(0, HEAP_PAGE_SIZE)]
                ^ [mk_Slot(0, 0) | i in set {1, ..., POOL_PAGE_SIZE - 1}]];
            poolCleanerPageIndex := 1;
            poolCleanerIndex := 1);
    
    addPage : () ==> ()
    addPage() ==
        atomic(heapPages := heapPages ^ [[0 | i in set {1, ..., HEAP_PAGE_SIZE}]];
            poolPages
                := poolPages
                ^ [[mk_Slot(0, HEAP_PAGE_SIZE)]
                ^ [mk_Slot(0, 0) | i in set {1, ..., POOL_PAGE_SIZE - 1}]]);
    
    basic_read : Pointer ==> Qword
    basic_read(pointer) ==
        let
            heap = heapPages(pointer div HEAP_PAGE_SIZE + 1),
            address = pointer mod HEAP_PAGE_SIZE + 1
        in
            return heap(address)
                + (heap(address + 1)
                    + (heap(address + 2)
                        + (heap(address + 3)
                            + (heap(address + 4)
                                + +(heap(address + 5)
                                    + (heap(address + 6) + heap(address + 7)  * 0x100)  * 0x100)
                                 * 0x100)
                             * 0x100)
                         * 0x100)
                     * 0x100)
                 * 0x100
    pre 
        pointer mod HEAP_PAGE_SIZE <= HEAP_PAGE_SIZE - 8
        and pointer div HEAP_PAGE_SIZE < len heapPages;
    
    basic_write : Pointer * Qword ==> ()
    basic_write(pointer, data) ==
        let
            page = pointer div HEAP_PAGE_SIZE + 1,
            address = pointer mod HEAP_PAGE_SIZE + 1
        in
            (dcl d:nat := data;
            heapPages(page)(address) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 1) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 2) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 3) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 4) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 5) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 6) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 7) := d mod 0x100)
    pre 
        pointer mod HEAP_PAGE_SIZE <= HEAP_PAGE_SIZE - 8
        and pointer div HEAP_PAGE_SIZE < len heapPages;
    
    basic_read_dword : Pointer ==> Dword
    basic_read_dword(pointer) ==
        let
            heap = heapPages(pointer div HEAP_PAGE_SIZE + 1),
            address = pointer mod HEAP_PAGE_SIZE + 1
        in
            return heap(address)
                + (heap(address + 1)
                    + (heap(address + 2) + heap(address + 3)  * 0x100)  * 0x100)
                 * 0x100
    pre 
        pointer mod HEAP_PAGE_SIZE <= HEAP_PAGE_SIZE - 4
        and pointer div HEAP_PAGE_SIZE < len heapPages;
    
    basic_write_dword : Pointer * Dword ==> ()
    basic_write_dword(pointer, data) ==
        let
            page = pointer div HEAP_PAGE_SIZE + 1,
            address = pointer mod HEAP_PAGE_SIZE + 1
        in
            (dcl d:nat := data;
            heapPages(page)(address) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 1) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 2) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 3) := d mod 0x100)
    pre 
        pointer mod HEAP_PAGE_SIZE <= HEAP_PAGE_SIZE - 4
        and pointer div HEAP_PAGE_SIZE < len heapPages;
    
    basic_read_byte : Pointer ==> Byte
    basic_read_byte(pointer) ==
        let
            heap = heapPages(pointer div HEAP_PAGE_SIZE + 1),
            address = pointer mod HEAP_PAGE_SIZE + 1
        in return heap(address)
    pre  pointer div HEAP_PAGE_SIZE < len heapPages;
    
    basic_write_byte : Pointer * Byte ==> ()
    basic_write_byte(pointer, data) ==
        let
            page = pointer div HEAP_PAGE_SIZE + 1,
            address = pointer mod HEAP_PAGE_SIZE + 1
        in heapPages(page)(address) := data
    pre  pointer div HEAP_PAGE_SIZE < len heapPages;
    
    alloc : Dword ==> [Pointer]
    alloc(raw_size) ==
        let size = align(CONTENT_OFFSET + raw_size)
        in
            (for page = 1 to  len poolPages
            do
                let pool = poolPages(page)
                in
                    for i = 1 to  len pool
                    do
                        (let newSize = pool(i).size - size
                        in
                            if
                                newSize >= 0
                            then
                                let
                                    address = pool(i).address,
                                    pointer = (page - 1)  * HEAP_PAGE_SIZE + address
                                in
                                    (poolPages(page)(i) .address := pool(i).address + size;
                                    poolPages(page)(i) .size := newSize;
                                    basic_write_dword(pointer + SIZE_OFFSET, size);
                                    basic_write_dword(pointer + FLAGS_OFFSET, 0);
                                    basic_write(pointer + REFERENCE_COUNT_OFFSET, 0);
                                    basic_write(pointer + FORWARDER_OFFSET, invalidPointerValue);
                                    return pointer));
            return nil);
    
    free : Pointer ==> ()
    free(pointer) ==
        let
            size = basic_read_dword(pointer + SIZE_OFFSET),
            page = pointer div HEAP_PAGE_SIZE + 1,
            pool = poolPages(page),
            address = pointer mod HEAP_PAGE_SIZE
        in
            (basic_write_dword(pointer + SIZE_OFFSET, 0);
            for i = 1 to  len pool
            do
                (if
                    pool(i).address + pool(i).size = address
                then
                    (poolPages(page)(i) .size := pool(i).size + size;
                    return );
                if
                    address + size = pool(i).address
                then
                    (atomic(poolPages(page)(i) .address := address;
                        poolPages(page)(i) .size := pool(i).size + size);
                    return ));
            for i = 1 to  len pool
            do
                (if
                    pool(i).size = 0
                then
                    (atomic(poolPages(page)(i) .address := address;
                        poolPages(page)(i) .size := size);
                    return )));
    
    cleanPool : () ==> ()
    cleanPool() ==
        (if
            poolPages(poolCleanerPageIndex)(poolCleanerIndex).size > 0
        then
            let
                pool = poolPages(poolCleanerPageIndex),
                endAddress =
                    pool(poolCleanerIndex).address + pool(poolCleanerIndex).size
            in
                for index = 1 to  POOL_PAGE_SIZE
                do
                    if
                        pool(index).size > 0 and pool(index).address = endAddress
                    then
                        atomic(poolPages(poolCleanerPageIndex)(poolCleanerIndex) .size
                                := pool(poolCleanerIndex).size + pool(index).size;
                            poolPages(poolCleanerPageIndex)(index) .size := 0);
        poolCleanerIndex := poolCleanerIndex mod POOL_PAGE_SIZE + 1;
        if
            poolCleanerIndex = 1
        then
            (poolCleanerPageIndex := poolCleanerPageIndex mod len poolPages + 1;
            if
                poolCleanerPageIndex = 1
                and (forall i in set {1, ..., POOL_PAGE_SIZE} &
                        poolPages(len poolPages)(i).size = 0)
            then
                atomic(heapPages := reverse (tl (reverse heapPages));
                    poolPages := reverse (tl (reverse poolPages)))));
    
    incrementReferenceCount : Pointer ==> ()
    incrementReferenceCount(pointer) ==
        basic_write(
            pointer + REFERENCE_COUNT_OFFSET,
            basic_read(pointer + REFERENCE_COUNT_OFFSET) + 1);
    
    decrementReferenceCount : Pointer ==> ()
    decrementReferenceCount(pointer) ==
        let p = pointer + REFERENCE_COUNT_OFFSET, c = basic_read(p) - 1
        in if c > 0 then basic_write(p, c) else free(pointer);
    
    p_current_State : () ==> State
    p_current_State() == return State;

end Memory
