module Memory
imports
    from Instruction operations err;,
    from Data
        types
            Byte renamed Byte;
            Word renamed Word;
            Dword renamed Dword;
            Qword renamed Qword;
            OID renamed OID;
            Int renamed Int;
            Float renamed Float;
            Char renamed Char;
            Pointer renamed Pointer;
        functions oid2pointer renamed oid2pointer;
        values
            invalidPointerValue renamed invalidPointerValue;
            invalidOidValue renamed invalidOidValue;
exports all
definitions
types
     Slot :: address : Pointer size : Qword;

values
     /* CONSTANTS ON MEMORY SPACE */
     ALIGNMENT = 64;
     HEAP_PAGE_SIZE = 4  * 1024;
     POOL_PAGE_SIZE = HEAP_PAGE_SIZE div ALIGNMENT;
     /* DATA STRUCTURE OF ALLOCATED MEMORY */
     MAX_OBJECT_SIZE = 1024; -- dword
     SIZE_OFFSET = 0; -- dword
     FLAGS_OFFSET = 4; -- qword
     REFERENCE_COUNT_OFFSET = 8; -- qword
     FORWARDER_OFFSET = 16;
     SLOTS_SIZE_OFFSET = 24;
     /* FLAGS IN "basic_read_dword(pointer + FLAGS_OFFSET)" */
     CONTENT_OFFSET = 32; --- if 1, the object is a large virtual object
     LARGE_OBJECT_FLAG = 1;

functions
    align : Qword -> Qword
    align(x) == ((x - 1) div ALIGNMENT + 1)  * ALIGNMENT;

state State of
    heapPages : seq of (seq of Byte)
    poolPages : seq of (seq of Slot)
    poolCleanerPageIndex : nat1
    poolCleanerIndex : nat1
inv mk_State(heaps, pools, pageIndex, index) ==
    (len heaps = len pools and pageIndex <= len pools)
    and index <= POOL_PAGE_SIZE
init s ==
    s
    = mk_State(
        [[0 | i in set {1, ..., HEAP_PAGE_SIZE}]],
        [[mk_Slot(0, HEAP_PAGE_SIZE)]
        ^ [mk_Slot(0, 0) | i in set {1, ..., POOL_PAGE_SIZE - 1}]],
        1,
        1)
end

operations
    reset : () ==> ()
    reset() ==
        atomic(heapPages := [[0 | i in set {1, ..., HEAP_PAGE_SIZE}]];
            poolPages
                := [[mk_Slot(0, HEAP_PAGE_SIZE)]
                ^ [mk_Slot(0, 0) | i in set {1, ..., POOL_PAGE_SIZE - 1}]];
            poolCleanerPageIndex := 1;
            poolCleanerIndex := 1);
    
    alloc : Qword ==> [Pointer]
    alloc(num_slots) ==
        let size = align(CONTENT_OFFSET + num_slots  * 8)
        in
            (for page = 1 to  len poolPages
            do
                let pool = poolPages(page)
                in
                    for i = 1 to  len pool
                    do
                        (let newSize = pool(i).size - size
                        in
                            if
                                newSize >= 0
                            then
                                let
                                    address = pool(i).address,
                                    pointer = (page - 1)  * HEAP_PAGE_SIZE + address
                                in
                                    (poolPages(page)(i) .address := pool(i).address + size;
                                    poolPages(page)(i) .size := newSize;
                                    basic_write_dword(pointer + SIZE_OFFSET, size);
                                    basic_write_dword(pointer + FLAGS_OFFSET, 0);
                                    basic_write(pointer + REFERENCE_COUNT_OFFSET, 0);
                                    basic_write(pointer + FORWARDER_OFFSET, invalidPointerValue);
                                    basic_write(pointer + SLOTS_SIZE_OFFSET, num_slots);
                                    for i = 0 to  num_slots - 1
                                    do basic_write(pointer + CONTENT_OFFSET + i  * 8, invalidOidValue);
                                    return pointer));
            return nil);
    
    free : Pointer ==> ()
    free(pointer) ==
        let
            size = basic_read_dword(pointer + SIZE_OFFSET),
            page = pointer div HEAP_PAGE_SIZE + 1,
            pool = poolPages(page),
            address = pointer mod HEAP_PAGE_SIZE
        in
            (basic_write_dword(pointer + SIZE_OFFSET, 0);
            for i = 0 to  slots_size(pointer) - 1
            do
                let p = oid2pointer(basic_read(pointer + CONTENT_OFFSET + i  * 8))
                in if p <> invalidPointerValue then decrementReferenceCount(p);
            for i = 1 to  len pool
            do
                (if
                    pool(i).address + pool(i).size = address
                then
                    (poolPages(page)(i) .size := pool(i).size + size;
                    return );
                if
                    address + size = pool(i).address
                then
                    (atomic(poolPages(page)(i) .address := address;
                        poolPages(page)(i) .size := pool(i).size + size);
                    return ));
            for i = 1 to  len pool
            do
                (if
                    pool(i).size = 0
                then
                    (atomic(poolPages(page)(i) .address := address;
                        poolPages(page)(i) .size := size);
                    return )));
    
    pure slots_size : Pointer ==> Dword
    slots_size(pointer) ==
        return basic_read(pointer + SLOTS_SIZE_OFFSET);
    
    insert_slot : Pointer * Int * OID ==> ()
    insert_slot(pointer, index, oid) ==
        let
            size = basic_read_dword(pointer + SIZE_OFFSET),
            old_slots_size = slots_size(pointer),
            new_slots_size = old_slots_size + 1
        in
            (if
                CONTENT_OFFSET + new_slots_size  * 8 <= size
            then
                (basic_write(pointer + SLOTS_SIZE_OFFSET, new_slots_size);
                for i = index to  old_slots_size
                do
                    basic_write(
                        pointer + CONTENT_OFFSET + i  * 8,
                        basic_read(pointer + CONTENT_OFFSET + (i - 1)  * 8));
                basic_write(pointer + CONTENT_OFFSET + (index - 1)  * 8, oid))
            else
                error)
    pre  index > 0 and index <= slots_size(pointer) + 1;
    
    pure read_slot : Pointer * Int ==> OID
    read_slot(pointer, index) ==
        return basic_read(pointer + CONTENT_OFFSET + (index - 1)  * 8)
    pre  index > 0 and index <= slots_size(pointer);
    
    write_slot : Pointer * Int * OID ==> ()
    write_slot(pointer, index, oid) ==
        (let oidPointer = oid2pointer(oid)
        in
            if
                oidPointer <> invalidPointerValue
            then
                incrementReferenceCount(oidPointer);
        let
            address = pointer + CONTENT_OFFSET + (index - 1)  * 8,
            oldPointer = oid2pointer(basic_read(address))
        in
            (if
                oldPointer <> invalidPointerValue
            then
                decrementReferenceCount(oldPointer);
            basic_write(address, oid)))
    pre  index > 0 and index <= slots_size(pointer);
    
    addPage : () ==> ()
    addPage() ==
        atomic(heapPages := heapPages ^ [[0 | i in set {1, ..., HEAP_PAGE_SIZE}]];
            poolPages
                := poolPages
                ^ [[mk_Slot(0, HEAP_PAGE_SIZE)]
                ^ [mk_Slot(0, 0) | i in set {1, ..., POOL_PAGE_SIZE - 1}]]);
    
    pure basic_read : Pointer ==> Qword
    basic_read(pointer) ==
        let
            heap = heapPages(pointer div HEAP_PAGE_SIZE + 1),
            address = pointer mod HEAP_PAGE_SIZE + 1
        in
            return heap(address)
                + (heap(address + 1)
                    + (heap(address + 2)
                        + (heap(address + 3)
                            + (heap(address + 4)
                                + +(heap(address + 5)
                                    + (heap(address + 6) + heap(address + 7)  * 0x100)  * 0x100)
                                 * 0x100)
                             * 0x100)
                         * 0x100)
                     * 0x100)
                 * 0x100
    pre 
        pointer mod HEAP_PAGE_SIZE <= HEAP_PAGE_SIZE - 8
        and pointer div HEAP_PAGE_SIZE < len heapPages;
    
    basic_write : Pointer * Qword ==> ()
    basic_write(pointer, data) ==
        let
            page = pointer div HEAP_PAGE_SIZE + 1,
            address = pointer mod HEAP_PAGE_SIZE + 1
        in
            (dcl d:nat := data;
            heapPages(page)(address) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 1) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 2) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 3) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 4) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 5) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 6) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 7) := d mod 0x100)
    pre 
        pointer mod HEAP_PAGE_SIZE <= HEAP_PAGE_SIZE - 8
        and pointer div HEAP_PAGE_SIZE < len heapPages;
    
    pure basic_read_dword : Pointer ==> Dword
    basic_read_dword(pointer) ==
        let
            heap = heapPages(pointer div HEAP_PAGE_SIZE + 1),
            address = pointer mod HEAP_PAGE_SIZE + 1
        in
            return heap(address)
                + (heap(address + 1)
                    + (heap(address + 2) + heap(address + 3)  * 0x100)  * 0x100)
                 * 0x100
    pre 
        pointer mod HEAP_PAGE_SIZE <= HEAP_PAGE_SIZE - 4
        and pointer div HEAP_PAGE_SIZE < len heapPages;
    
    basic_write_dword : Pointer * Dword ==> ()
    basic_write_dword(pointer, data) ==
        let
            page = pointer div HEAP_PAGE_SIZE + 1,
            address = pointer mod HEAP_PAGE_SIZE + 1
        in
            (dcl d:nat := data;
            heapPages(page)(address) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 1) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 2) := d mod 0x100;
            d := d div 0x100;
            heapPages(page)(address + 3) := d mod 0x100)
    pre 
        pointer mod HEAP_PAGE_SIZE <= HEAP_PAGE_SIZE - 4
        and pointer div HEAP_PAGE_SIZE < len heapPages;
    
    pure basic_read_byte : Pointer ==> Byte
    basic_read_byte(pointer) ==
        let
            heap = heapPages(pointer div HEAP_PAGE_SIZE + 1),
            address = pointer mod HEAP_PAGE_SIZE + 1
        in return heap(address)
    pre  pointer div HEAP_PAGE_SIZE < len heapPages;
    
    basic_write_byte : Pointer * Byte ==> ()
    basic_write_byte(pointer, data) ==
        let
            page = pointer div HEAP_PAGE_SIZE + 1,
            address = pointer mod HEAP_PAGE_SIZE + 1
        in heapPages(page)(address) := data
    pre  pointer div HEAP_PAGE_SIZE < len heapPages;
    
    cleanPool : () ==> ()
    cleanPool() ==
        (if
            poolPages(poolCleanerPageIndex)(poolCleanerIndex).size > 0
        then
            let
                pool = poolPages(poolCleanerPageIndex),
                endAddress =
                    pool(poolCleanerIndex).address + pool(poolCleanerIndex).size
            in
                for index = 1 to  POOL_PAGE_SIZE
                do
                    if
                        pool(index).size > 0 and pool(index).address = endAddress
                    then
                        atomic(poolPages(poolCleanerPageIndex)(poolCleanerIndex) .size
                                := pool(poolCleanerIndex).size + pool(index).size;
                            poolPages(poolCleanerPageIndex)(index) .size := 0);
        poolCleanerIndex := poolCleanerIndex mod POOL_PAGE_SIZE + 1;
        if
            poolCleanerIndex = 1
        then
            (poolCleanerPageIndex := poolCleanerPageIndex mod len poolPages + 1;
            if
                poolCleanerPageIndex = 1
                and (forall i in set {1, ..., POOL_PAGE_SIZE} &
                        poolPages(len poolPages)(i).size = 0)
            then
                atomic(heapPages := reverse (tl (reverse heapPages));
                    poolPages := reverse (tl (reverse poolPages)))));
    
    incrementReferenceCount : Pointer ==> ()
    incrementReferenceCount(pointer) ==
        basic_write(
            pointer + REFERENCE_COUNT_OFFSET,
            basic_read(pointer + REFERENCE_COUNT_OFFSET) + 1);
    
    decrementReferenceCount : Pointer ==> ()
    decrementReferenceCount(pointer) ==
        let p = pointer + REFERENCE_COUNT_OFFSET, c = basic_read(p) - 1
        in
            (basic_write(p, c);
            if c = 0 then free(pointer));

end Memory
