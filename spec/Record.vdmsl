module Record
imports
    from Data all,
    from Memory all,
    from Equality all
exports all
definitions
types
     FieldSpec :: name : seq of char equality : bool;

values
     CNAME_SLOT = 1;
     FSPEC_SIZE = 2;
     FSPEC_NAME_SLOT = 1;
     FSPEC_EQUALITY = 2;
     TYPE_SLOT = 1;
     ELEMENTS_SLOT_OFFSET = 1;

operations
    alloc : Data`Qword ==> Data`OID
    alloc(s) ==
        return Data`pointer2oid(Memory`alloc(s + ELEMENTS_SLOT_OFFSET))
            + Data`recordTag;
    
    make : Data`OID * seq of Data`OID ==> Data`OID
    make(type, oids) ==
        let p : Data`Pointer = Memory`alloc(len oids)
        in
            (Memory`write_slot(p, TYPE_SLOT, type);
            for i = 1 to  len oids
            do Memory`write_slot(p, i + ELEMENTS_SLOT_OFFSET, oids(i));
            return Data`pointer2oid(p) + Data`recordTag)
    pre  type <> Data`invalidOidValue;
    
    size : Data`OID ==> Data`Qword
    size(oid) ==
        return Memory`slots_size(Data`oid2pointer(oid)) - ELEMENTS_SLOT_OFFSET
    pre  Data`isRecord(oid);
    
    read_constructor : Data`OID ==> Data`OID
    read_constructor(oid) ==
        return Memory`read_slot(Data`oid2pointer(oid), TYPE_SLOT)
    pre  Data`isRecord(oid);
    
    read : Data`OID * Data`Qword ==> Data`OID
    read(oid, index) ==
        return Memory`read_slot(
                Data`oid2pointer(oid), index + ELEMENTS_SLOT_OFFSET)
    pre 
        (Data`isRecord(oid) and index > ELEMENTS_SLOT_OFFSET)
        and Memory`slots_size(Data`oid2pointer(oid))
        >= index + ELEMENTS_SLOT_OFFSET;
    
    write : Data`OID * Data`Qword * Data`OID ==> ()
    write(oid, index, elem) ==
        return Memory`write_slot(
                Data`oid2pointer(oid), index + ELEMENTS_SLOT_OFFSET, elem)
    pre 
        (Data`isRecord(oid) and index > ELEMENTS_SLOT_OFFSET)
        and Memory`slots_size(Data`oid2pointer(oid))
        >= index + ELEMENTS_SLOT_OFFSET;
    
    equal : Data`OID * Data`OID ==> bool
    equal(oid1, oid2) ==
        let
            p1 : Data`Pointer = Data`oid2pointer(oid1),
            p2 : Data`Pointer = Data`oid2pointer(oid2)
        in
            (if p1 = p2 then return true;
            if
                phash(p1) <> phash(p2)
                or Memory`slots_size(p1) <> Memory`slots_size(p2)
            then
                return false;
            for i = 1 to  Memory`slots_size(p1)
            do
                if
                    not Equality`equal(Memory`read_slot(p1, i), Memory`read_slot(p2, i))
                then
                    return false;
            return true)
    pre  Data`isRecord(oid1) and Data`isRecord(oid2);
    
    hash : Data`OID ==> Equality`Hash
    hash(oid) == return phash(Data`oid2pointer(oid))
    pre  Data`isRecord(oid);
    
    phash : Data`Pointer ==> Equality`Hash
    phash(p) ==
        let cachedHash : Equality`Hash = Memory`read_hash(p)
        in
            (if
                cachedHash = Equality`invalidHashValue
            then
                (dcl h:int := 0;
                for i = 1 to  Memory`slots_size(p)
                do
                    let oid = Memory`read_slot(p, i)
                    in if oid <> Data`invalidOidValue then h := h + Equality`hash(oid);
                h := h mod (Equality`hashMask + 1);
                Memory`write_hash(p, h);
                return h)
            else
                return cachedHash);

end Record
