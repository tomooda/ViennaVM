module Register
imports
    from Data all,
    from Memory all
exports all
definitions
types
     Reg ::
        oid : Data`OID
        i : Data`Int
        f : Data`Float
        c : Data`Char
        p : Data`Pointer;
     Register = nat;

state State of
    codeRecord : Data`Pointer
    instructionPointer : Data`Dword
    activationRecord : Data`Pointer
    registers : seq of Reg
init s ==
    s
    = mk_State(
        Data`invalidPointerValue,
        0,
        Data`invalidPointerValue,
        [mk_Reg(
            Data`invalidOidValue,
            Data`invalidIntValue,
            Data`invalidFloatValue,
            Data`invalidCharValue,
            Data`invalidPointerValue)
            | i in set {1, ..., 16}])
end

operations
    read_cr : () ==> Data`Pointer
    read_cr() == return codeRecord;
    
    write_cr : Data`Pointer ==> ()
    write_cr(pointer) ==
        let old_cr = codeRecord
        in
            (codeRecord := pointer;
            instructionPointer := 0;
            if
                codeRecord <> Data`invalidPointerValue
            then
                Memory`increment_reference_count(codeRecord);
            if
                old_cr <> Data`invalidPointerValue
            then
                Memory`decrement_reference_count(old_cr));
    
    read_ip : () ==> Data`Dword
    read_ip() == return instructionPointer;
    
    write_ip : Data`Dword ==> ()
    write_ip(i) == instructionPointer := i;
    
    read_ar : () ==> Data`Pointer
    read_ar() == return activationRecord;
    
    write_ar : Data`Pointer ==> ()
    write_ar(ar) ==
        let old_ar = activationRecord
        in
            (activationRecord := ar;
            if ar <> Data`invalidPointerValue then Memory`increment_reference_count(ar);
            if
                old_ar <> Data`invalidPointerValue
            then
                Memory`decrement_reference_count(old_ar));
    
    move : Register * Register ==> ()
    move(dst, src) ==
        (let reg = registers(src), p1 = reg.p
        in
            (if
                p1 = Data`invalidPointerValue
            then
                (let p2 = Data`oid2pointer(reg.oid)
                in
                    if p2 <> Data`invalidPointerValue then Memory`increment_reference_count(p2))
            else
                Memory`increment_reference_count(p1));
        let p1 = registers(dst).p
        in
            (if
                p1 <> Data`invalidPointerValue
            then
                Memory`decrement_reference_count(p1)
            else
                let p2 = Data`oid2pointer(registers(dst).oid)
                in
                    if p2 <> Data`invalidPointerValue then Memory`decrement_reference_count(p2));
        registers(dst) := registers(src));
    
    read_oid : Register ==> Data`OID
    read_oid(r) ==
        let register : Reg = registers(r)
        in
            if register.oid <> Data`invalidTag
                then return register.oid
            elseif register.i <> Data`invalidIntValue
                then (dcl oid:Data`OID := Data`int2oid(register.i);
                registers(r) .oid := oid;
                return oid)
            elseif register.f <> Data`invalidFloatValue
                then (dcl oid:Data`OID := Data`float2oid(register.f);
                registers(r) .oid := oid;
                return oid)
            elseif register.c <> Data`invalidCharValue
                then (dcl oid:Data`OID := Data`char2oid(register.c);
                registers(r) .oid := oid;
                return oid)
            elseif register.p <> Data`invalidPointerValue
                then (dcl oid:Data`OID := Data`pointer2oid(register.p);
                registers(r) .oid := oid;
                return oid)
            else
                return Data`invalidTag;
    
    write_oid : Register * Data`OID ==> ()
    write_oid(r, oid) ==
        (let p1 = registers(r).p, p2 = Data`oid2pointer(oid)
        in
            (if p1 <> Data`invalidPointerValue then Memory`decrement_reference_count(p1);
            if p2 <> Data`invalidPointerValue then Memory`increment_reference_count(p2));
        registers(r)
            := mk_Reg(
                oid,
                Data`invalidIntValue,
                Data`invalidFloatValue,
                Data`invalidCharValue,
                Data`oid2pointer(oid)));
    
    read_int : Register ==> Data`Int
    read_int(r) ==
        let reg : Reg = registers(r), i : [Data`Int] = reg.i
        in
            if
                i = Data`invalidIntValue
            then
                let i2 : Data`Int = Data`oid2int(reg.oid)
                in
                    (if i2 <> Data`invalidIntValue then registers(r) .i := i2;
                    return i2)
            else
                return i;
    
    write_int : Register * Data`Int ==> ()
    write_int(r, i) ==
        (let p = registers(r).p
        in
            if p <> Data`invalidPointerValue then Memory`decrement_reference_count(p);
        registers(r)
            := mk_Reg(
                Data`invalidTag,
                i,
                Data`invalidFloatValue,
                Data`invalidCharValue,
                Data`invalidPointerValue));
    
    read_float : Register ==> Data`Float
    read_float(r) ==
        let reg : Reg = registers(r), f : [Data`Float] = reg.f
        in
            if
                f = Data`invalidFloatValue
            then
                let f2 : Data`Float = Data`oid2float(reg.oid)
                in
                    if
                        f2 <> Data`invalidFloatValue
                    then
                        (registers(r) .f := f2;
                        return f2)
                    else
                        let i : Data`Int = read_int(r)
                        in
                            if
                                i <> Data`invalidIntValue
                            then
                                let f3 : Data`Float = Data`real2float(i)
                                in
                                    (registers(r) .f := f3;
                                    return f3)
                            else
                                return Data`invalidFloatValue
            else
                return f;
    
    write_float : Register * Data`Float ==> ()
    write_float(r, f) ==
        (let p = registers(r).p
        in
            if p <> Data`invalidPointerValue then Memory`decrement_reference_count(p);
        registers(r)
            := mk_Reg(
                Data`invalidTag,
                Data`invalidIntValue,
                f,
                Data`invalidCharValue,
                Data`invalidPointerValue));
    
    read_char : Register ==> Data`Char
    read_char(r) ==
        let reg : Reg = registers(r), c : [Data`Char] = reg.c
        in
            if
                c = Data`invalidCharValue
            then
                let c2 : Data`Char = Data`oid2char(reg.oid)
                in
                    (registers(r) .c := c2;
                    return c2)
            else
                return c;
    
    write_char : Register * Data`Char ==> ()
    write_char(r, c) ==
        (let p = registers(r).p
        in
            if p <> Data`invalidPointerValue then Memory`decrement_reference_count(p);
        registers(r)
            := mk_Reg(
                Data`invalidTag,
                Data`invalidIntValue,
                Data`invalidFloatValue,
                c,
                Data`invalidPointerValue));
    
    read_pointer : Register ==> Data`Pointer
    read_pointer(r) ==
        let reg : Reg = registers(r), p : [Data`Pointer] = reg.p
        in
            if
                p = Data`invalidPointerValue
            then
                let p2 : Data`Pointer = Data`oid2pointer(reg.oid)
                in
                    (registers(r) .p := p2;
                    return p2)
            else
                return p;
    
    write_pointer : Register * Data`Pointer ==> ()
    write_pointer(r, p) ==
        (let p1 = registers(r).p
        in
            if p1 <> Data`invalidPointerValue then Memory`decrement_reference_count(p1);
        if p <> Data`invalidPointerValue then Memory`increment_reference_count(p);
        registers(r)
            := mk_Reg(
                Data`invalidTag,
                Data`invalidIntValue,
                Data`invalidFloatValue,
                Data`invalidCharValue,
                p));

end Register
