module Register
imports
    from Data
        types
            Dword renamed Dword;
            OID renamed OID;
            Int renamed Int;
            Float renamed Float;
            Char renamed Char;
            Pointer renamed Pointer;
        values
            invalidTag: OID renamed invalidTag;
            invalidOidValue: OID renamed invalidOidValue;
            invalidIntValue: Int renamed invalidIntValue;
            invalidFloatValue: Float renamed invalidFloatValue;
            invalidCharValue: Char renamed invalidCharValue;
            invalidPointerValue: Pointer renamed invalidPointerValue;
        functions
            int2oid: Int -> OID renamed int2oid;
            float2oid: Float -> OID renamed float2oid;
            char2oid: Char -> OID renamed char2oid;
            pointer2oid: Pointer -> OID renamed pointer2oid;
            oid2int: OID -> Int renamed oid2int;
            oid2float: OID -> Float renamed oid2float;
            oid2char: OID -> Char renamed oid2char;
            oid2pointer: OID -> Pointer renamed oid2pointer;,
    from Memory
        operations
            incrementReferenceCount: Pointer ==> ()
                renamed incrementReferenceCount;
            decrementReferenceCount: Pointer ==> ()
                renamed decrementReferenceCount;
exports all
definitions
types
     Reg :: oid : OID i : Int f : Float c : Char p : Pointer;
     GeneralRegister = nat;
     NamedRegister = seq of char;
     Register = GeneralRegister| NamedRegister;

state State of
    codeRecord : Pointer
    instructionPointer : Dword
    registers : seq of Reg
    namedRegisters : map NamedRegister to Reg
init s ==
    s
    = mk_State(
        invalidPointerValue,
        0,
        [mk_Reg(
            invalidOidValue,
            invalidIntValue,
            invalidFloatValue,
            invalidCharValue,
            invalidPointerValue)
            | i in set {1, ..., 16}],
        {"zero"
        |-> mk_Reg(
            int2oid(0), 0, invalidFloatValue, invalidCharValue, invalidPointerValue)})
end

operations
    read_cr : () ==> Pointer
    read_cr() == return codeRecord;
    
    write_cr : Pointer ==> ()
    write_cr(pointer) == codeRecord := pointer;
    
    read_ip : () ==> Dword
    read_ip() == return instructionPointer;
    
    write_ip : Dword ==> ()
    write_ip(i) == instructionPointer := i;
    
    jump : Dword ==> ()
    jump(index) == instructionPointer := index;
    
    jump_relative : int ==> ()
    jump_relative(offset) ==
        instructionPointer := instructionPointer + offset;
    
    move : GeneralRegister * Register ==> ()
    move(dst, src) ==
        (let
            reg =
                if is_(src, GeneralRegister) then registers(src) else namedRegisters(src),
            p1 = reg.p
        in
            (if
                p1 = invalidPointerValue
            then
                (let p2 = oid2pointer(reg.oid)
                in if p2 <> invalidPointerValue then incrementReferenceCount(p2))
            else
                incrementReferenceCount(p1));
        let p1 = registers(dst).p
        in
            (if
                p1 <> invalidPointerValue
            then
                decrementReferenceCount(p1)
            else
                let p2 = oid2pointer(registers(dst).oid)
                in if p2 <> invalidPointerValue then decrementReferenceCount(p2));
        registers(dst)
            := if is_(src, GeneralRegister) then registers(src) else namedRegisters(src));
    
    read_oid : Register ==> OID
    read_oid(r) ==
        let
            register : Reg =
                if is_(r, GeneralRegister) then registers(r) else namedRegisters(r)
        in
            if register.oid <> invalidTag
                then return register.oid
            elseif register.i <> invalidIntValue
                then (dcl oid:OID := int2oid(register.i);
                registers(r) .oid := oid;
                return oid)
            elseif register.f <> invalidFloatValue
                then (dcl oid:OID := float2oid(register.f);
                registers(r) .oid := oid;
                return oid)
            elseif register.c <> invalidCharValue
                then (dcl oid:OID := char2oid(register.c);
                registers(r) .oid := oid;
                return oid)
            elseif register.p <> invalidPointerValue
                then (dcl oid:OID := pointer2oid(register.p);
                registers(r) .oid := oid;
                return oid)
            else
                return invalidTag;
    
    write_oid : GeneralRegister * OID ==> ()
    write_oid(r, oid) ==
        (let p1 = registers(r).p, p2 = oid2pointer(oid)
        in
            (if p1 <> invalidPointerValue then decrementReferenceCount(p1);
            if p2 <> invalidPointerValue then incrementReferenceCount(p2));
        registers(r)
            := mk_Reg(
                oid,
                invalidIntValue,
                invalidFloatValue,
                invalidCharValue,
                oid2pointer(oid)));
    
    read_tag : Register ==> OID
    read_tag(r) == return read_oid(r) mod 0x100;
    
    write_tag : GeneralRegister * OID ==> ()
    write_tag(r, tag) ==
        (let p = registers(r).p
        in if p <> invalidPointerValue then decrementReferenceCount(p);
        registers(r)
            := mk_Reg(
                read_oid(r) div 0x100  * 0x100 + tag,
                invalidIntValue,
                invalidFloatValue,
                invalidCharValue,
                invalidPointerValue));
    
    read_int : Register ==> Int
    read_int(r) ==
        let
            reg : Reg =
                if is_(r, GeneralRegister) then registers(r) else namedRegisters(r),
            i : [Int] = reg.i
        in
            if
                i = invalidIntValue and is_(r, GeneralRegister)
            then
                let i2 : Int = oid2int(reg.oid)
                in
                    (if
                        i2 <> invalidIntValue and is_(r, GeneralRegister)
                    then
                        registers(r) .i := i2;
                    return i2)
            else
                return i;
    
    write_int : GeneralRegister * Int ==> ()
    write_int(r, i) ==
        (let p = registers(r).p
        in if p <> invalidPointerValue then decrementReferenceCount(p);
        registers(r)
            := mk_Reg(
                invalidTag, i, invalidFloatValue, invalidCharValue, invalidPointerValue));
    
    read_float : Register ==> Float
    read_float(r) ==
        let
            reg : Reg =
                if is_(r, GeneralRegister) then registers(r) else namedRegisters(r),
            f : [Float] = reg.f
        in
            if
                f = invalidFloatValue and is_(r, GeneralRegister)
            then
                let f2 : Float = oid2float(reg.oid)
                in
                    (if f2 <> invalidFloatValue then registers(r) .f := f2;
                    return f2)
            else
                return f;
    
    write_float : GeneralRegister * Float ==> ()
    write_float(r, f) ==
        (let p = registers(r).p
        in if p <> invalidPointerValue then decrementReferenceCount(p);
        registers(r)
            := mk_Reg(
                invalidTag, invalidIntValue, f, invalidCharValue, invalidPointerValue));
    
    read_char : Register ==> Char
    read_char(r) ==
        let
            reg : Reg =
                if is_(r, GeneralRegister) then registers(r) else namedRegisters(r),
            c : [Char] = reg.c
        in
            if
                c = invalidCharValue and is_(r, GeneralRegister)
            then
                let c2 : Char = oid2char(reg.oid)
                in
                    (registers(r) .c := c2;
                    return c2)
            else
                return c;
    
    write_char : GeneralRegister * Char ==> ()
    write_char(r, c) ==
        (let p = registers(r).p
        in if p <> invalidPointerValue then decrementReferenceCount(p);
        registers(r)
            := mk_Reg(
                invalidTag, invalidIntValue, invalidFloatValue, c, invalidPointerValue));
    
    read_pointer : Register ==> Pointer
    read_pointer(r) ==
        let
            reg : Reg =
                if is_(r, GeneralRegister) then registers(r) else namedRegisters(r),
            p : [Pointer] = reg.p
        in
            if
                p = invalidPointerValue and is_(r, GeneralRegister)
            then
                let p2 : Pointer = oid2pointer(reg.oid)
                in
                    (registers(r) .p := p2;
                    return p2)
            else
                return p;
    
    write_pointer : GeneralRegister * Pointer ==> ()
    write_pointer(r, p) ==
        (let p1 = registers(r).p
        in if p1 <> invalidPointerValue then decrementReferenceCount(p1);
        if p <> invalidPointerValue then incrementReferenceCount(p);
        registers(r)
            := mk_Reg(
                invalidTag, invalidIntValue, invalidFloatValue, invalidCharValue, p));
    
    define_named_oid : seq of char * OID ==> ()
    define_named_oid(name, oid) ==
        if
            name in set dom namedRegisters
        then
            skip
        else
            namedRegisters(name)
                := mk_Reg(
                    oid, oid2int(oid), oid2float(oid), oid2char(oid), oid2pointer(oid));
    
    define_named_int : seq of char * Int ==> ()
    define_named_int(name, i) ==
        if
            name in set dom namedRegisters
        then
            skip
        else
            namedRegisters(name)
                := mk_Reg(
                    int2oid(i), i, invalidFloatValue, invalidCharValue, invalidPointerValue);
    
    define_named_float : seq of char * Float ==> ()
    define_named_float(name, f) ==
        if
            name in set dom namedRegisters
        then
            skip
        else
            namedRegisters(name)
                := mk_Reg(
                    float2oid(f), invalidIntValue, f, invalidCharValue, invalidPointerValue);
    
    define_named_char : seq of char * Char ==> ()
    define_named_char(name, c) ==
        if
            name in set dom namedRegisters
        then
            skip
        else
            namedRegisters(name)
                := mk_Reg(
                    char2oid(c), invalidIntValue, invalidFloatValue, c, invalidPointerValue);
    
    define_named_pointer : seq of char * Pointer ==> ()
    define_named_pointer(name, p) ==
        if
            name in set dom namedRegisters
        then
            skip
        else
            namedRegisters(name)
                := mk_Reg(
                    pointer2oid(p), invalidIntValue, invalidFloatValue, invalidCharValue, p);

end Register
