module Register
imports
    from Data
        types
            OID renamed OID;
            Int renamed Int;
            Float renamed Float;
            Char renamed Char;
            Pointer renamed Pointer;
        values
            invalidTag: OID renamed invalidTag;
            invalidOidValue: OID renamed invalidOidValue;
            invalidIntValue: Int renamed invalidIntValue;
            invalidFloatValue: Float renamed invalidFloatValue;
            invalidCharValue: Char renamed invalidCharValue;
            invalidPointerValue: Pointer renamed invalidPointerValue;
        functions
            int2oid: Int -> OID renamed int2oid;
            float2oid: Float -> OID renamed float2oid;
            char2oid: Char -> OID renamed char2oid;
            pointer2oid: Pointer -> OID renamed pointer2oid;
            oid2int: OID -> Int renamed oid2int;
            oid2float: OID -> Float renamed oid2float;
            oid2char: OID -> Char renamed oid2char;
            oid2pointer: OID -> Pointer renamed oid2pointer;,
    from Memory
        operations
            incrementReferenceCount: Pointer ==> ()
                renamed incrementReferenceCount;
            decrementReferenceCount: Pointer ==> ()
                renamed decrementReferenceCount;
exports all
definitions
types
     Reg :: oid : OID i : Int f : Float c : Char p : Pointer;

state State of
    registers : seq of Reg
    namedRegisters : map seq of char to Reg
init s ==
    s
    = mk_State(
        [mk_Reg(
            invalidOidValue,
            invalidIntValue,
            invalidFloatValue,
            invalidCharValue,
            invalidPointerValue)
            | i in set {1, ..., 16}],
        {"zero"
        |-> mk_Reg(
            int2oid(0), 0, invalidFloatValue, invalidCharValue, invalidPointerValue)})
end

operations
    read_oid : nat ==> OID
    read_oid(r) ==
        let register : Reg = registers(r)
        in
            if register.oid <> invalidTag
                then return register.oid
            elseif register.i <> invalidIntValue
                then (dcl oid:OID := int2oid(register.i);
                registers(r) .oid := oid;
                return oid)
            elseif register.f <> invalidFloatValue
                then (dcl oid:OID := float2oid(register.f);
                registers(r) .oid := oid;
                return oid)
            elseif register.c <> invalidCharValue
                then (dcl oid:OID := char2oid(register.c);
                registers(r) .oid := oid;
                return oid)
            elseif register.p <> invalidPointerValue
                then (dcl oid:OID := pointer2oid(register.p);
                registers(r) .oid := oid;
                return oid)
            else
                return invalidTag;
    
    write_oid : nat * OID ==> ()
    write_oid(r, oid) ==
        (let p1 = registers(r).p, p2 = oid2pointer(oid)
        in
            (if p1 <> invalidPointerValue then decrementReferenceCount(p1);
            if p2 <> invalidPointerValue then incrementReferenceCount(p2));
        registers(r)
            := mk_Reg(
                oid,
                invalidIntValue,
                invalidFloatValue,
                invalidCharValue,
                oid2pointer(oid)));
    
    read_tag : nat ==> OID
    read_tag(r) == return read_oid(r) mod 0x100;
    
    write_tag : nat * OID ==> ()
    write_tag(r, tag) ==
        (let p = registers(r).p
        in if p <> invalidPointerValue then decrementReferenceCount(p);
        registers(r)
            := mk_Reg(
                read_oid(r) + tag,
                invalidIntValue,
                invalidFloatValue,
                invalidCharValue,
                invalidPointerValue));
    
    read_int : nat ==> Int
    read_int(r) ==
        let i : [Int] = registers(r).i
        in
            if
                i <> invalidIntValue
            then
                return i
            else
                let i2 : Int = oid2int(registers(r).oid)
                in
                    (registers(r) .i := i2;
                    return i2);
    
    write_int : nat * Int ==> ()
    write_int(r, i) ==
        (let p = registers(r).p
        in if p <> invalidPointerValue then decrementReferenceCount(p);
        registers(r)
            := mk_Reg(
                invalidTag, i, invalidFloatValue, invalidCharValue, invalidPointerValue));
    
    read_float : nat ==> Float
    read_float(r) ==
        let f : [Float] = registers(r).f
        in
            if
                f <> invalidFloatValue
            then
                return f
            else
                let f2 : Float = oid2float(registers(r).oid)
                in
                    (registers(r) .f := f2;
                    return f2);
    
    write_float : nat * Float ==> ()
    write_float(r, f) ==
        (let p = registers(r).p
        in if p <> invalidPointerValue then decrementReferenceCount(p);
        registers(r)
            := mk_Reg(
                invalidTag, invalidIntValue, f, invalidCharValue, invalidPointerValue));
    
    read_char : nat ==> Char
    read_char(r) ==
        let c : [Char] = registers(r).c
        in
            if
                c <> invalidCharValue
            then
                return c
            else
                let c2 : Char = oid2char(registers(r).oid)
                in
                    (registers(r) .c := c2;
                    return c2);
    
    write_char : nat * Char ==> ()
    write_char(r, c) ==
        (let p = registers(r).p
        in if p <> invalidPointerValue then decrementReferenceCount(p);
        registers(r)
            := mk_Reg(
                invalidTag, invalidIntValue, invalidFloatValue, c, invalidPointerValue));
    
    read_pointer : nat ==> Pointer
    read_pointer(r) ==
        let p : [Pointer] = registers(r).p
        in
            if
                p <> invalidPointerValue
            then
                return p
            else
                let p2 : Pointer = oid2pointer(registers(r).oid)
                in
                    (registers(r) .p := p2;
                    return p2);
    
    write_pointer : nat * Pointer ==> ()
    write_pointer(r, p) ==
        (let p1 = registers(r).p
        in if p1 <> invalidPointerValue then decrementReferenceCount(p1);
        if p <> invalidPointerValue then incrementReferenceCount(p);
        registers(r)
            := mk_Reg(
                invalidTag, invalidIntValue, invalidFloatValue, invalidCharValue, p));
    
    read_named_oid : seq of char ==> OID
    read_named_oid(name) ==
        return if
                name in set dom namedRegisters
            then
                namedRegisters(name).oid
            else
                invalidOidValue;
    
    read_named_int : seq of char ==> Int
    read_named_int(name) ==
        return if
                name in set dom namedRegisters
            then
                namedRegisters(name).i
            else
                invalidIntValue;
    
    read_named_float : seq of char ==> Float
    read_named_float(name) ==
        return if
                name in set dom namedRegisters
            then
                namedRegisters(name).f
            else
                invalidFloatValue;
    
    read_named_char : seq of char ==> Char
    read_named_char(name) ==
        return if
                name in set dom namedRegisters
            then
                namedRegisters(name).c
            else
                invalidCharValue;
    
    read_named_pointer : seq of char ==> Pointer
    read_named_pointer(name) ==
        return if
                name in set dom namedRegisters
            then
                namedRegisters(name).p
            else
                invalidPointerValue;
    
    define_named_oid : seq of char * OID ==> ()
    define_named_oid(name, oid) ==
        if
            name in set dom namedRegisters
        then
            skip
        else
            namedRegisters(name)
                := mk_Reg(
                    oid, oid2int(oid), oid2float(oid), oid2char(oid), oid2pointer(oid));
    
    define_named_int : seq of char * Int ==> ()
    define_named_int(name, i) ==
        if
            name in set dom namedRegisters
        then
            skip
        else
            namedRegisters(name)
                := mk_Reg(
                    int2oid(i), i, invalidFloatValue, invalidCharValue, invalidPointerValue);
    
    define_named_float : seq of char * Float ==> ()
    define_named_float(name, f) ==
        if
            name in set dom namedRegisters
        then
            skip
        else
            namedRegisters(name)
                := mk_Reg(
                    float2oid(f), invalidIntValue, f, invalidCharValue, invalidPointerValue);
    
    define_named_char : seq of char * Char ==> ()
    define_named_char(name, c) ==
        if
            name in set dom namedRegisters
        then
            skip
        else
            namedRegisters(name)
                := mk_Reg(
                    char2oid(c), invalidIntValue, invalidFloatValue, c, invalidPointerValue);
    
    define_named_pointer : seq of char * Pointer ==> ()
    define_named_pointer(name, p) ==
        if
            name in set dom namedRegisters
        then
            skip
        else
            namedRegisters(name)
                := mk_Reg(
                    pointer2oid(p), invalidIntValue, invalidFloatValue, invalidCharValue, p);

end Register
