module Register
imports
    from Data
        types
            OID renamed OID;
            Int renamed Int;
            Float renamed Float;
            Char renamed Char;
            Pointer renamed Pointer;
        values
            invalidTag: OID renamed invalidTag;
            invalidOidValue: OID renamed invalidOidValue;
            invalidIntValue: Int renamed invalidIntValue;
            invalidFloatValue: Float renamed invalidFloatValue;
            invalidCharValue: Char renamed invalidCharValue;
            invalidPointerValue: Pointer renamed invalidPointerValue;
        functions
            int2oid: Int -> OID renamed int2oid;
            float2oid: Float -> OID renamed float2oid;
            char2oid: Char -> OID renamed char2oid;
            pointer2oid: Pointer -> OID renamed pointer2oid;
            oid2int: OID -> Int renamed oid2int;
            oid2float: OID -> Float renamed oid2float;
            oid2char: OID -> Char renamed oid2char;
            oid2pointer: OID -> Pointer renamed oid2pointer;
exports all
definitions
types
     Register :: oid : OID i : Int f : Float c : Char p : Pointer;

state State of
    registers : seq of Register
init s ==
    s
    = mk_State(
        [mk_Register(
            invalidOidValue,
            invalidIntValue,
            invalidFloatValue,
            invalidCharValue,
            invalidPointerValue)
            | i in set {1, ..., 16}])
end

operations
    read_oid : nat ==> OID
    read_oid(r) ==
        let register : Register = registers(r)
        in
            if register.oid <> invalidTag
                then return register.oid
            elseif register.i <> invalidTag
                then (dcl oid:OID := int2oid(register.i);
                registers(r) .oid := oid;
                return oid)
            elseif register.f <> invalidFloatValue
                then (dcl oid:OID := float2oid(register.f);
                registers(r) .oid := oid;
                return oid)
            elseif register.c <> invalidCharValue
                then (dcl oid:OID := char2oid(register.c);
                registers(r) .oid := oid;
                return oid)
            elseif register.p <> invalidPointerValue
                then (dcl oid:OID := pointer2oid(register.p);
                registers(r) .oid := oid;
                return oid)
            else
                return invalidTag;
    
    write_oid : nat * OID ==> ()
    write_oid(r, oid) ==
        registers(r)
            := mk_Register(
                oid,
                invalidIntValue,
                invalidFloatValue,
                invalidCharValue,
                invalidPointerValue);
    
    read_tag : nat ==> OID
    read_tag(r) == return read_oid(r) mod 0x100;
    
    write_tag : nat * OID ==> ()
    write_tag(r, tag) ==
        registers(r)
            := mk_Register(
                read_oid(r) + tag,
                invalidIntValue,
                invalidFloatValue,
                invalidCharValue,
                invalidPointerValue);
    
    read_int : nat ==> Int
    read_int(r) ==
        let i : [Int] = registers(r).i
        in
            if
                i <> invalidIntValue
            then
                return i
            else
                let i2 : Int = oid2int(registers(r).oid)
                in
                    (registers(r) .i := i2;
                    return i2);
    
    write_int : nat * Int ==> ()
    write_int(r, i) ==
        registers(r)
            := mk_Register(
                invalidTag, i, invalidFloatValue, invalidCharValue, invalidPointerValue);
    
    read_float : nat ==> Float
    read_float(r) ==
        let f : [Float] = registers(r).f
        in
            if
                f <> invalidFloatValue
            then
                return f
            else
                let f2 : Float = oid2float(registers(r).oid)
                in
                    (registers(r) .f := f2;
                    return f2);
    
    write_float : nat * Float ==> ()
    write_float(r, f) ==
        registers(r)
            := mk_Register(
                invalidTag, invalidIntValue, f, invalidCharValue, invalidPointerValue);
    
    read_char : nat ==> Char
    read_char(r) ==
        let c : [Char] = registers(r).c
        in
            if
                c <> invalidCharValue
            then
                return c
            else
                let c2 : Char = oid2char(registers(r).oid)
                in
                    (registers(r) .c := c2;
                    return c2);
    
    write_char : nat * Char ==> ()
    write_char(r, c) ==
        registers(r)
            := mk_Register(
                invalidTag, invalidIntValue, invalidFloatValue, c, invalidPointerValue);
    
    read_pointer : nat ==> Pointer
    read_pointer(r) ==
        let p : [Pointer] = registers(r).p
        in
            if
                p <> invalidPointerValue
            then
                return p
            else
                let p2 : Pointer = oid2pointer(registers(r).oid)
                in
                    (registers(r) .p := p2;
                    return p2);
    
    write_pointer : nat * Pointer ==> ()
    write_pointer(r, p) ==
        registers(r)
            := mk_Register(
                invalidTag, invalidIntValue, invalidFloatValue, invalidCharValue, p);

end Register
