module Seq
imports
    from Data all,
    from Memory all,
    from Equality all
exports all
definitions
operations
    alloc : Data`Qword ==> Data`OID
    alloc(s) == return Data`pointer2oid(Memory`alloc(s)) + Data`seqTag
    pre  s >= 1;
    
    make : seq of Data`OID ==> Data`OID
    make(oids) ==
        if
            oids = []
        then
            return Data`emptySeqValue
        else
            let p : Data`Pointer = Memory`alloc(len oids)
            in
                (for i = 1 to  len oids do Memory`write_slot(p, i, oids(i));
                return Data`pointer2oid(p) + Data`seqTag);
    
    make_string : seq of char ==> Data`OID
    make_string(string) ==
        return make([Data`char2oid(Data`char2int(c)) | c in seq string]);
    
    size : Data`OID ==> Data`Qword
    size(oid) ==
        return if oid = Data`emptySeqValue then 0 else Memory`slots_size(Data`oid2pointer(oid))
    pre  Data`isSeq(oid);
    
    read : Data`OID * Data`Qword ==> Data`OID
    read(oid, index) ==
        return Memory`read_slot(Data`oid2pointer(oid), index)
    pre 
        (Data`isSeq(oid) and index >= 1)
        and Memory`slots_size(Data`oid2pointer(oid)) >= index;
    
    write : Data`OID * Data`Qword * Data`OID ==> ()
    write(oid, index, elem) ==
        Memory`write_slot(Data`oid2pointer(oid), index, elem)
    pre 
        (Data`isSeq(oid) and index >= 1)
        and Memory`slots_size(Data`oid2pointer(oid)) >= index;
    
    equal : Data`OID * Data`OID ==> bool
    equal(oid1, oid2) ==
        let
            p1 : Data`Pointer = Data`oid2pointer(oid1),
            p2 : Data`Pointer = Data`oid2pointer(oid2)
        in
            (if p1 = p2 then return true;
            if
                phash(p1) <> phash(p2)
                or Memory`slots_size(p1) <> Memory`slots_size(p2)
            then
                return false;
            for i = 1 to  Memory`slots_size(p1)
            do
                if
                    not Equality`equal(Memory`read_slot(p1, i), Memory`read_slot(p2, i))
                then
                    return false;
            return true)
    pre  Data`isSeq(oid1) and Data`isSeq(oid2);
    
    hash : Data`OID ==> Equality`Hash
    hash(oid) == return phash(Data`oid2pointer(oid))
    pre  Data`isSeq(oid);
    
    phash : Data`Pointer ==> Equality`Hash
    phash(p) ==
        let cachedHash : Equality`Hash = Memory`read_hash(p)
        in
            (if
                cachedHash = Equality`invalidHashValue
            then
                (dcl h:int := 0;
                for i = 1 to  Memory`slots_size(p)
                do
                    let oid = Memory`read_slot(p, i)
                    in
                        if oid <> Data`invalidOidValue then h := h  * 3 + Equality`hash(oid);
                h := h mod (Equality`hashMask + 1);
                Memory`write_hash(p, h);
                return h)
            else
                return cachedHash);

end Seq
