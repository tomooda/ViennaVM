module Tuple
imports
    from Data all,
    from Memory all,
    from Equality all
exports all
definitions
operations
    alloc : Data`Qword ==> Data`OID
    alloc(s) ==
        return Data`pointer2oid(Memory`alloc(s)) + Data`tupleTag
    pre  s >= 2;
    
    make : seq of Data`OID ==> Data`OID
    make(oids) ==
        let p : Data`Pointer = Memory`alloc(len oids)
        in
            (for i = 1 to  len oids do Memory`write_slot(p, i, oids(i));
            return Data`pointer2oid(p) + Data`tupleTag)
    pre  len oids >= 2;
    
    size : Data`OID ==> Data`Qword
    size(oid) == return Memory`slots_size(Data`oid2pointer(oid))
    pre  Data`isTuple(oid);
    
    read : Data`OID * Data`Qword ==> Data`OID
    read(oid, index) ==
        return Memory`read_slot(Data`oid2pointer(oid), index)
    pre 
        (Data`isTuple(oid) and index >= 1)
        and Memory`slots_size(Data`oid2pointer(oid)) >= index;
    
    write : Data`OID * Data`Qword * Data`OID ==> ()
    write(oid, index, elem) ==
        return Memory`write_slot(Data`oid2pointer(oid), index, elem)
    pre 
        (Data`isTuple(oid) and index >= 1)
        and Memory`slots_size(Data`oid2pointer(oid)) >= index;
    
    equal : Data`OID * Data`OID ==> bool
    equal(oid1, oid2) ==
        let
            p1 : Data`Pointer = Data`oid2pointer(oid1),
            p2 : Data`Pointer = Data`oid2pointer(oid2)
        in
            (if p1 = p2 then return true;
            if
                phash(p1) <> phash(p2)
                or Memory`slots_size(p1) <> Memory`slots_size(p2)
            then
                return false;
            for i = 1 to  Memory`slots_size(p1)
            do
                if
                    not Equality`equal(Memory`read_slot(p1, i), Memory`read_slot(p2, i))
                then
                    return false;
            return true)
    pre  Data`isTuple(oid1) and Data`isTuple(oid2);
    
    hash : Data`OID ==> Equality`Hash
    hash(oid) == return phash(Data`oid2pointer(oid))
    pre  Data`isTuple(oid);
    
    phash : Data`Pointer ==> Equality`Hash
    phash(p) ==
        let cachedHash : Equality`Hash = Memory`read_hash(p)
        in
            (if
                cachedHash = Equality`invalidHashValue
            then
                (dcl h:int := 0;
                for i = 1 to  Memory`slots_size(p)
                do
                    let oid = Memory`read_slot(p, i)
                    in if oid <> Data`invalidOidValue then h := h + Equality`hash(oid);
                h := h mod (Equality`hashMask + 1);
                Memory`write_hash(p, h);
                return h)
            else
                return cachedHash);

end Tuple
